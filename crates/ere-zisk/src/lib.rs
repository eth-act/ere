use crate::{
    compile::compile_zisk_program,
    error::{ExecuteError, ProveError, VerifyError, ZiskError},
};
use serde::{Deserialize, Serialize};
use std::{
    fs,
    io::Write,
    path::{Path, PathBuf},
    process::{Command, Stdio},
    time,
};
use tempfile::tempdir;
use zkvm_interface::{
    Compiler, Input, ProgramExecutionReport, ProgramProvingReport, ProverResourceType, zkVM,
    zkVMError,
};

mod compile;
mod error;

#[allow(non_camel_case_types)]
pub struct RV64_IMA_ZISK_ZKVM_ELF;

impl Compiler for RV64_IMA_ZISK_ZKVM_ELF {
    type Error = ZiskError;

    /// Path to compiled ELF.
    type Program = PathBuf;

    fn compile(path_to_program: &Path) -> Result<Self::Program, Self::Error> {
        compile_zisk_program(path_to_program).map_err(ZiskError::Compile)
    }
}

#[derive(Serialize, Deserialize)]
pub struct ZiskProofWithPublicValues {
    /// The raw aggregated proof generated by the ZisK zkVM.
    pub proof: Vec<u8>,
    /// The public values generated by the ZisK zkVM.
    pub public_values: Vec<u8>,
}

pub struct EreZisk {
    elf_path: PathBuf,
    resource: ProverResourceType,
}

impl EreZisk {
    pub fn new(elf_path: PathBuf, resource: ProverResourceType) -> Self {
        Self { elf_path, resource }
    }
}

impl EreZisk {}

impl zkVM for EreZisk {
    fn execute(&self, input: &Input) -> Result<ProgramExecutionReport, zkVMError> {
        let input_bytes = input
            .iter()
            .try_fold(Vec::new(), |mut acc, item| {
                acc.extend(item.as_bytes().map_err(ExecuteError::SerializeInput)?);
                Ok(acc)
            })
            .map_err(ZiskError::Execute)?;

        let output_dir = tempdir().map_err(|e| ZiskError::Execute(ExecuteError::Io(e)))?;
        let input_path = input_path(output_dir.path());

        fs::File::create(&input_path)
            .and_then(|mut file| file.write_all(&input_bytes))
            .map_err(|e| ZiskError::Execute(ExecuteError::Io(e)))?;

        let output = Command::new("ziskemu")
            .arg("-e")
            .arg(&self.elf_path)
            .arg("-i")
            .arg(&input_path)
            .arg("-x")
            .stderr(Stdio::inherit())
            .output()
            .map_err(|e| ZiskError::Execute(ExecuteError::Ziskemu { source: e }))?;

        if !output.status.success() {
            return Err(ZiskError::Execute(ExecuteError::ZiskemuFailed {
                status: output.status,
            })
            .into());
        }

        let total_num_cycles = String::from_utf8_lossy(&output.stdout)
            .split_once("total steps = ")
            .and_then(|(_, stats)| {
                stats
                    .split_whitespace()
                    .next()
                    .and_then(|steps| steps.parse::<u64>().ok())
            })
            .ok_or(ZiskError::Execute(ExecuteError::TotalStepsNotFound))?;

        Ok(ProgramExecutionReport::new(total_num_cycles))
    }

    fn prove(&self, input: &Input) -> Result<(Vec<u8>, ProgramProvingReport), zkVMError> {
        let input_bytes = input
            .iter()
            .try_fold(Vec::new(), |mut acc, item| {
                acc.extend(item.as_bytes().map_err(ProveError::SerializeInput)?);
                Ok(acc)
            })
            .map_err(ZiskError::Prove)?;

        let output_dir = tempdir().map_err(|e| ZiskError::Prove(ProveError::Io(e)))?;
        let input_path = input_path(output_dir.path());
        let proof_path = proof_path(output_dir.path());
        let public_values_path = public_values_path(output_dir.path());

        fs::File::create(&input_path)
            .and_then(|mut file| file.write_all(&input_bytes))
            .map_err(|e| ZiskError::Prove(ProveError::Io(e)))?;

        let start = time::Instant::now();
        match self.resource {
            ProverResourceType::Cpu => {
                let status = Command::new("cargo-zisk")
                    .arg("prove")
                    .arg("-e")
                    .arg(&self.elf_path)
                    .arg("-i")
                    .arg(&input_path)
                    .arg("-o")
                    .arg(output_dir.path())
                    // FIXME: Not sure why if we don't set the flag `aggregation`
                    //        there will be no proof, but ideally we should
                    //        only generate the core proof as other zkVMs.
                    .arg("-a")
                    .status()
                    .map_err(|e| ZiskError::Prove(ProveError::CargoZiskProve { source: e }))?;

                if !status.success() {
                    return Err(
                        ZiskError::Prove(ProveError::CargoZiskProveFailed { status }).into(),
                    );
                }
            }
            ProverResourceType::Gpu => {
                // TODO: Need to install another version of `cargo-zisk` with
                //       `features = gpu` and call it here.
                unimplemented!()
            }
        }
        let proving_time = start.elapsed();

        let proof_with_public_values = ZiskProofWithPublicValues {
            proof: fs::read(proof_path).map_err(|e| ZiskError::Prove(ProveError::Io(e)))?,
            public_values: fs::read(public_values_path)
                .map_err(|e| ZiskError::Prove(ProveError::Io(e)))?,
        };
        let bytes = bincode::serialize(&proof_with_public_values)
            .map_err(|err| ZiskError::Prove(ProveError::Bincode(err)))?;

        Ok((bytes, ProgramProvingReport::new(proving_time)))
    }

    fn verify(&self, bytes: &[u8]) -> Result<(), zkVMError> {
        let proof_with_public_values: ZiskProofWithPublicValues = bincode::deserialize(bytes)
            .map_err(|err| ZiskError::Verify(VerifyError::Bincode(err)))?;

        let output_dir = tempdir().map_err(|e| ZiskError::Verify(VerifyError::Io(e)))?;
        let proof_path = proof_path(output_dir.path());
        let public_values_path = public_values_path(output_dir.path());
        fs::create_dir_all(proof_dir(output_dir.path()))
            .map_err(|e| ZiskError::Verify(VerifyError::Io(e)))?;

        fs::File::create(&proof_path)
            .and_then(|mut file| file.write_all(&proof_with_public_values.proof))
            .map_err(|e| ZiskError::Verify(VerifyError::Io(e)))?;
        fs::File::create(&public_values_path)
            .and_then(|mut file| file.write_all(&proof_with_public_values.public_values))
            .map_err(|e| ZiskError::Verify(VerifyError::Io(e)))?;

        let output = Command::new("cargo-zisk")
            .arg("verify")
            .arg("-p")
            .arg(&proof_path)
            .arg("-u")
            .arg(&public_values_path)
            .output()
            .map_err(|e| ZiskError::Verify(VerifyError::CargoZiskVerify { source: e }))?;

        if !output.status.success() {
            return Err(ZiskError::Verify(VerifyError::InvalidProof(
                String::from_utf8_lossy(&output.stderr).to_string(),
            ))
            .into());
        }

        Ok(())
    }
}

fn input_path(dir: impl AsRef<Path>) -> PathBuf {
    dir.as_ref().join("input.bin")
}

fn proof_dir(dir: impl AsRef<Path>) -> PathBuf {
    dir.as_ref().join("proofs")
}

fn proof_path(dir: impl AsRef<Path>) -> PathBuf {
    proof_dir(dir).join("vadcop_final_proof.json")
}

fn public_values_path(dir: impl AsRef<Path>) -> PathBuf {
    dir.as_ref().join("publics.json")
}

#[cfg(test)]
mod execute_tests {
    use super::*;

    fn get_compiled_test_zisk_elf() -> Result<PathBuf, ZiskError> {
        let test_guest_path = get_execute_test_guest_program_path();
        RV64_IMA_ZISK_ZKVM_ELF::compile(&test_guest_path)
    }

    fn get_execute_test_guest_program_path() -> PathBuf {
        let workspace_dir = env!("CARGO_WORKSPACE_DIR");
        PathBuf::from(workspace_dir)
            .join("tests")
            .join("zisk")
            .join("execute")
            .join("basic")
            .canonicalize()
            .expect("Failed to find or canonicalize test guest program at <CARGO_WORKSPACE_DIR>/tests/execute/zisk")
    }

    #[test]
    fn test_execute_zisk_dummy_input() {
        let elf_path = get_compiled_test_zisk_elf()
            .expect("Failed to compile test ZisK guest for execution test");

        let mut input_builder = Input::new();
        let n: u32 = 42;
        let a: u16 = 42;
        input_builder.write(n);
        input_builder.write(a);

        let zkvm = EreZisk::new(elf_path, ProverResourceType::Cpu);

        let result = zkvm.execute(&input_builder);

        if let Err(e) = &result {
            panic!("Execution error: {e:?}");
        }
    }

    #[test]
    fn test_execute_zisk_no_input_for_guest_expecting_input() {
        let elf_path = get_compiled_test_zisk_elf()
            .expect("Failed to compile test ZisK guest for execution test");

        let empty_input = Input::new();

        let zkvm = EreZisk::new(elf_path, ProverResourceType::Cpu);
        assert!(zkvm.execute(&empty_input).is_err());
    }
}

#[cfg(test)]
mod prove_tests {
    use std::path::PathBuf;

    use super::*;
    use zkvm_interface::Input;

    fn get_prove_test_guest_program_path() -> PathBuf {
        let workspace_dir = env!("CARGO_WORKSPACE_DIR");
        PathBuf::from(workspace_dir)
            .join("tests")
            .join("zisk")
            .join("prove")
            .join("basic")
            .canonicalize()
            .expect("Failed to find or canonicalize test guest program at <CARGO_WORKSPACE_DIR>/tests/execute/zisk")
    }

    fn get_compiled_test_zisk_elf_for_prove() -> Result<PathBuf, ZiskError> {
        let test_guest_path = get_prove_test_guest_program_path();
        RV64_IMA_ZISK_ZKVM_ELF::compile(&test_guest_path)
    }

    #[test]
    fn test_prove_zisk_dummy_input() {
        let elf_path = get_compiled_test_zisk_elf_for_prove()
            .expect("Failed to compile test ZisK guest for proving test");

        let mut input_builder = Input::new();
        let n: u32 = 42;
        let a: u16 = 42;
        input_builder.write(n);
        input_builder.write(a);

        let zkvm = EreZisk::new(elf_path, ProverResourceType::Cpu);

        let proof_bytes = match zkvm.prove(&input_builder) {
            Ok((prove_result, _)) => prove_result,
            Err(err) => {
                panic!("Proving error in test: {err:?}");
            }
        };

        assert!(!proof_bytes.is_empty(), "Proof bytes should not be empty.");

        assert!(zkvm.verify(&proof_bytes).is_ok());

        let invalid_proof_bytes = {
            let mut invalid_proof: ZiskProofWithPublicValues =
                bincode::deserialize(&proof_bytes).unwrap();
            // alter the first digit of `evals[0][0]`
            invalid_proof.proof[40] = invalid_proof.proof[40].overflowing_add(1).0;
            bincode::serialize(&invalid_proof).unwrap()
        };
        assert!(zkvm.verify(&invalid_proof_bytes).is_err());

        // TODO: Check public inputs
    }

    #[test]
    fn test_prove_zisk_fails_on_bad_input_causing_execution_failure() {
        let elf_path = get_compiled_test_zisk_elf_for_prove()
            .expect("Failed to compile test ZisK guest for proving test");

        let empty_input = Input::new();

        let zkvm = EreZisk::new(elf_path, ProverResourceType::Cpu);
        assert!(zkvm.prove(&empty_input).is_err());
    }
}
