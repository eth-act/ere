use crate::zkvm::Error;
use ere_zkvm_interface::zkvm::{CommonError, ProverResourceType, PublicValues};
use std::{
    collections::BTreeMap,
    env, fs,
    io::BufRead,
    iter,
    path::{Path, PathBuf},
    process::{Child, Command},
    sync::OnceLock,
    thread,
    time::{Duration, Instant},
};
use strum::{EnumIter, IntoEnumIterator};
use tempfile::tempdir;
use tracing::{error, info};

/// Merkle root of ROM trace generated by `cargo-zisk rom-setup`.
pub type RomDigest = [u64; 4];

/// Options of `cargo-zisk` commands.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, EnumIter)]
pub enum ZiskOption {
    Port,
    UnlockMappedMemory, // Should be set if locked memory is not enough
    MinimalMemory,
    // GPU options
    Preallocate, // Should be set only if GPU memory is enough
    SharedTables,
    MaxStreams,
    NumberThreadsWitness,
    MaxWitnessStored,
}

impl ZiskOption {
    /// The key of the env variable to read from.
    fn env_var_key(&self) -> &'static str {
        match self {
            Self::Port => "ZISK_PORT",
            Self::UnlockMappedMemory => "ZISK_UNLOCK_MAPPED_MEMORY",
            Self::MinimalMemory => "ZISK_MINIMAL_MEMORY",
            Self::Preallocate => "ZISK_PREALLOCATE",
            Self::SharedTables => "ZISK_SHARED_TABLES",
            Self::MaxStreams => "ZISK_MAX_STREAMS",
            Self::NumberThreadsWitness => "ZISK_NUMBER_THREADS_WITNESS",
            Self::MaxWitnessStored => "ZISK_MAX_WITNESS_STORED",
        }
    }

    /// Whether the option is a flag (false-by-default boolean option) or not.
    ///
    /// When we read the option from env variable, if the option is a flag,
    /// we only check if the env variable is set or not.
    fn is_flag(&self) -> bool {
        match self {
            Self::UnlockMappedMemory
            | Self::MinimalMemory
            | Self::Preallocate
            | Self::SharedTables => true,
            Self::Port | Self::MaxStreams | Self::NumberThreadsWitness | Self::MaxWitnessStored => {
                false
            }
        }
    }

    /// The option key to be appended to `cargo-zisk` command arguments.
    fn key(&self) -> &'static str {
        match self {
            Self::Port => "--port",
            Self::UnlockMappedMemory => "--unlock-mapped-memory",
            // NOTE: Use snake case for `prove-client` command
            // Issue for tracking: https://github.com/eth-act/ere/issues/151.
            Self::MinimalMemory => "--minimal_memory",
            Self::Preallocate => "--preallocate",
            Self::SharedTables => "--shared-tables",
            Self::MaxStreams => "--max-streams",
            Self::NumberThreadsWitness => "--number-threads-witness",
            Self::MaxWitnessStored => "--max-witness-stored",
        }
    }
}

#[derive(Clone)]
pub struct ZiskOptions(BTreeMap<ZiskOption, String>);

impl ZiskOptions {
    /// Read options from env variables.
    pub fn from_env() -> Self {
        Self(
            ZiskOption::iter()
                .flat_map(|option| env::var(option.env_var_key()).ok().map(|val| (option, val)))
                .collect(),
        )
    }

    /// Returns `cargo-zisk` command arguments by given options that have been
    /// set.
    fn args(&self, options: impl IntoIterator<Item = ZiskOption>) -> impl Iterator<Item = &str> {
        options
            .into_iter()
            .filter(|option| self.0.contains_key(option))
            .flat_map(|option| {
                iter::once(option.key())
                    .chain((!option.is_flag()).then(|| self.0[&option].as_str()))
            })
    }

    /// Returns `cargo-zisk server` command arguments.
    fn server_args(&self) -> impl Iterator<Item = &str> {
        self.args([
            ZiskOption::Port,
            ZiskOption::UnlockMappedMemory,
            ZiskOption::Preallocate,
            ZiskOption::SharedTables,
            ZiskOption::MaxStreams,
            ZiskOption::NumberThreadsWitness,
            ZiskOption::MaxWitnessStored,
        ])
    }

    /// Returns `cargo-zisk prove-client` command arguments.
    fn prove_client_args(&self) -> impl Iterator<Item = &str> {
        self.args([ZiskOption::Port])
    }

    /// Returns `cargo-zisk prove-client prove` command arguments.
    fn prove_args(&self) -> impl Iterator<Item = &str> {
        self.prove_client_args()
            .chain(self.args([ZiskOption::MinimalMemory]))
    }
}

pub struct ZiskSdk {
    elf_path: PathBuf,
    resource: ProverResourceType,
    options: ZiskOptions,
    /// ROM digest will be setup only when `ZiskSdk::server` is called.
    ///
    /// Use `Option` inside because ROM setup might fail, we can get rid of
    /// it if `OnceLock::get_or_try_init` is stabilized.
    rom_digest: OnceLock<Option<RomDigest>>,
}

impl ZiskSdk {
    /// Returns SDK for the ELF.
    pub fn new(
        elf: Vec<u8>,
        resource: ProverResourceType,
        options: ZiskOptions,
    ) -> Result<Self, Error> {
        // Save ELF to `~/.zisk/cache` along with the ROM binaries, to avoid it
        // been cleaned up during a long run process.
        let cache_dir_path = dot_zisk_dir_path().join("cache");
        fs::create_dir_all(&cache_dir_path)
            .map_err(|err| CommonError::create_dir("cache", &cache_dir_path, err))?;

        // Use blake3 hash as the ELF file name, since ROM setup uses blake3 as
        // unique identifier as well.
        let elf_hash = blake3::hash(&elf);
        let elf_path = cache_dir_path.join(format!("{elf_hash}.elf"));

        fs::write(&elf_path, elf).map_err(|err| CommonError::write_file("elf", &elf_path, err))?;

        Ok(Self {
            elf_path,
            resource,
            options,
            rom_digest: OnceLock::new(),
        })
    }

    /// Execute the ELF with the given `input`.
    pub fn execute(&self, input: &[u8]) -> Result<(PublicValues, u64), Error> {
        let tempdir = tempdir().map_err(CommonError::tempdir)?;
        let input_path = tempdir.path().join("input");
        let output_path = tempdir.path().join("output");

        fs::write(&input_path, input)
            .map_err(|err| CommonError::write_file("input", &input_path, err))?;

        let mut cmd = Command::new("ziskemu");
        let output = cmd
            .arg("--elf")
            .arg(&self.elf_path)
            .arg("--inputs")
            .arg(input_path)
            .arg("--output")
            .arg(&output_path)
            .arg("--stats") // Enable stats in order to get total steps.
            .output()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if !output.status.success() {
            return Err(CommonError::command_exit_non_zero(
                &cmd,
                output.status,
                Some(&output),
            ))?;
        }

        // Extract cycle count from the stdout.

        let total_num_cycles = String::from_utf8_lossy(&output.stdout)
            .split_once("total steps = ")
            .and_then(|(_, stats)| {
                stats
                    .split_whitespace()
                    .next()
                    .and_then(|steps| steps.parse::<u64>().ok())
            })
            .ok_or(Error::TotalStepsNotFound)?;

        let public_values = fs::read(&output_path)
            .map_err(|err| CommonError::read_file("output", &output_path, err))?;

        Ok((public_values, total_num_cycles))
    }

    /// Returns the ROM digest of the ELF.
    ///
    /// If it is not setup yet, it makes sure the global setup is done, then
    /// does ROM setup of the ELF and stores the ROM digest for later usage.
    pub fn rom_digest(&self) -> Result<RomDigest, Error> {
        // FIXME: Use `get_or_try_init` when it is stabilized
        let mut result = Ok(());
        let rom_digest = *self.rom_digest.get_or_init(|| {
            check_setup()
                .and_then(|_| rom_setup(&self.elf_path))
                .map_err(|err| result = Err(err))
                .ok()
        });
        result?;
        rom_digest.ok_or(Error::RomSetupFailedBefore)
    }

    /// Start a server of the ELF.
    pub fn server(&self) -> Result<ZiskServer, Error> {
        // Setup ROM and get ROM digest if it's not done yet.
        let rom_digest = self.rom_digest()?;

        let (cargo_zisk, witness_lib_path) = match self.resource {
            ProverResourceType::Cpu => ("cargo-zisk", None),
            ProverResourceType::Gpu => (
                "cargo-zisk-cuda",
                Some(
                    dot_zisk_dir_path()
                        .join("bin")
                        .join("libzisk_witness_cuda.so"),
                ),
            ),
            ProverResourceType::Network(_) => {
                panic!(
                    "Network proving not yet implemented for ZisK. Use CPU or GPU resource type."
                );
            }
        };

        let mut cmd = Command::new(cargo_zisk);
        cmd.arg("server")
            .args(self.options.server_args())
            .arg("--elf")
            .arg(&self.elf_path)
            .arg("--aggregation");
        if let Some(witness_lib_path) = witness_lib_path {
            cmd.arg("--witness-lib").arg(witness_lib_path);
        }

        let child = cmd.spawn().map_err(|err| CommonError::command(&cmd, err))?;
        let server = ZiskServer {
            options: self.options.clone(),
            rom_digest,
            child,
        };

        server.wait_until_ready()?;

        Ok(server)
    }

    /// Verify the proof of the ELF, and returns public values.
    pub fn verify(&self, proof: &[u8]) -> Result<PublicValues, Error> {
        let rom_digest = self.rom_digest()?;

        let tempdir = tempdir().map_err(CommonError::tempdir)?;
        let proof_path = tempdir.path().join("proof");

        fs::write(&proof_path, proof)
            .map_err(|err| CommonError::write_file("proof", &proof_path, err))?;

        let mut cmd = Command::new("cargo-zisk");
        let output = cmd
            .arg("verify")
            .arg("--proof")
            .arg(&proof_path)
            .output()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if !output.status.success() {
            Err(Error::InvalidProof(
                String::from_utf8_lossy(&output.stderr).to_string(),
            ))?
        }

        let proof = fs::read(&proof_path)
            .map_err(|err| CommonError::read_file("proof", &proof_path, err))?;

        // Deserialize public values.
        let (proved_rom_digest, public_values) = deserialize_public_values(&proof)?;

        // The proved ROM digest should be equal to preprocessed one.
        if proved_rom_digest != rom_digest {
            return Err(Error::UnexpectedRomDigest {
                preprocessed: rom_digest,
                proved: proved_rom_digest,
            });
        }

        Ok(public_values)
    }
}

/// ZisK server status returned from `cargo-zisk prove-client status`.
pub enum ZiskServerStatus {
    Idle,
    Working,
}

/// Wrapper for ZisK server child process.
pub struct ZiskServer {
    options: ZiskOptions,
    rom_digest: RomDigest,
    child: Child,
}

impl Drop for ZiskServer {
    fn drop(&mut self) {
        let result = Command::new("cargo-zisk")
            .args(["prove-client", "shutdown"])
            .args(self.options.prove_client_args())
            .status();
        if result.is_err() || !result.unwrap().success() {
            self.child
                .kill()
                .unwrap_or_else(|err| error!("Failed to kill server: {err:?}"));
        }
    }
}

impl ZiskServer {
    /// Get status of server.
    pub fn status(&self) -> Result<ZiskServerStatus, Error> {
        let mut cmd = Command::new("cargo-zisk");
        let output = cmd
            .args(["prove-client", "status"])
            .args(self.options.prove_client_args())
            .output()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if !output.status.success() {
            return Err(CommonError::command_exit_non_zero(
                &cmd,
                output.status,
                Some(&output),
            ))?;
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        if stdout.contains("idle") {
            Ok(ZiskServerStatus::Idle)
        } else if stdout.contains("working") {
            Ok(ZiskServerStatus::Working)
        } else {
            Err(Error::UnknownServerStatus {
                stdout: stdout.to_string(),
            })
        }
    }

    /// Send prove request to server and wait for proof to be created.
    pub fn prove(&mut self, input: &[u8]) -> Result<(PublicValues, Vec<u8>), Error> {
        // Prefix that ZisK server will add to the file name of the proof.
        // We use constant because the file will be save to a temporary dir,
        // so there will be no conflict.
        const PREFIX: &str = "ere";

        let tempdir = tempdir().map_err(CommonError::tempdir)?;
        let input_path = tempdir.path().join("input");
        let output_path = tempdir.path().join("output");
        let proof_path = output_path.join(format!("{PREFIX}-vadcop_final_proof.bin"));

        fs::write(&input_path, input)
            .map_err(|err| CommonError::write_file("input", &input_path, err))?;

        // NOTE: Use snake case for `prove-client` command
        // Issue for tracking: https://github.com/eth-act/ere/issues/151.
        let mut cmd = Command::new("cargo-zisk");
        let output = cmd
            .args(["prove-client", "prove"])
            .arg("--input")
            .arg(input_path)
            .arg("--output_dir")
            .arg(&output_path)
            .args(["-p", PREFIX])
            .args(["--aggregation", "--verify_proofs"])
            .args(self.options.prove_args())
            .output()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if !output.status.success() {
            return Err(CommonError::command_exit_non_zero(
                &cmd,
                output.status,
                Some(&output),
            ))?;
        }

        // ZisK server will finish the `prove` requested above then respond the
        // following `status`. So if the following `status` succeeds, the proof
        // should also be ready.
        self.status()?;

        let proof = fs::read(&proof_path)
            .map_err(|err| CommonError::read_file("proof", &proof_path, err))?;

        // Deserialize public values.
        let (proved_rom_digest, public_values) = deserialize_public_values(&proof)?;

        // The proved ROM digest should be equal to preprocessed one.
        if proved_rom_digest != self.rom_digest {
            return Err(Error::UnexpectedRomDigest {
                preprocessed: self.rom_digest,
                proved: proved_rom_digest,
            });
        }

        Ok((public_values, proof))
    }

    /// Wait until the server status to be idle.
    fn wait_until_ready(&self) -> Result<(), Error> {
        const TIMEOUT: Duration = Duration::from_secs(300); // 5mins
        const INTERVAL: Duration = Duration::from_secs(1);

        let start = Instant::now();
        while !matches!(self.status(), Ok(ZiskServerStatus::Idle)) {
            if start.elapsed() > TIMEOUT {
                return Err(Error::TimeoutWaitingServerReady);
            }
            thread::sleep(INTERVAL);
        }

        Ok(())
    }
}

/// Does global setup if it is not done yet.
fn check_setup() -> Result<(), Error> {
    info!("Running command `cargo-zisk check-setup --aggregation`...");

    let mut cmd = Command::new("cargo-zisk");
    let output = cmd
        .args(["check-setup", "--aggregation"])
        .output()
        .map_err(|err| CommonError::command(&cmd, err))?;

    if !output.status.success() {
        Err(CommonError::command_exit_non_zero(
            &cmd,
            output.status,
            Some(&output),
        ))?;
    }

    info!("Command `cargo-zisk check-setup --aggregation` succeeded");

    Ok(())
}

/// Does ROM setup of the ELF and returns the ROM digest.
fn rom_setup(elf_path: &Path) -> Result<RomDigest, Error> {
    info!("Running command `cargo-zisk rom-setup` ...");

    let mut cmd = Command::new("cargo-zisk");
    let output = cmd
        .arg("rom-setup")
        .arg("--elf")
        .arg(elf_path)
        .output()
        .map_err(|err| CommonError::command(&cmd, err))?;

    if !output.status.success() {
        Err(CommonError::command_exit_non_zero(
            &cmd,
            output.status,
            Some(&output),
        ))?;
    }

    // Parse the ROM digest from the stdout.
    let rom_digest = output
        .stdout
        .lines()
        .find_map(|line| {
            let line = line.ok()?;
            let line = line.split_once("Root hash: [")?.1;
            let line = line.strip_suffix("]")?;
            line.split(", ")
                .filter_map(|word| word.parse::<u64>().ok())
                .collect::<Vec<_>>()
                .try_into()
                .ok()
        })
        .ok_or(Error::RomDigestNotFound)?;

    info!("Command `cargo-zisk rom-setup` succeeded");

    Ok(rom_digest)
}

/// Deserialize public values as json string sequence, and parse the `RomDigest`
/// and user set public values as `Vec<u8>`.
fn deserialize_public_values(proof: &[u8]) -> Result<(RomDigest, Vec<u8>), Error> {
    let proof = bytemuck::try_cast_slice::<_, u64>(proof).map_err(Error::CastProofBytesToU64s)?;

    // The public values contain at least the the total number of public values,
    // `RomDigest`, and the number of user set public values.
    if proof.len() < 6 {
        return Err(Error::InvalidPublicValuesLength(proof.len()));
    }

    // The first element is total number of public values.

    // The next 4 elements of public values should be ROM digest.
    let rom_digest = proof[1..5].try_into().unwrap();

    // The next element should be the number of user set public values.
    let num_user_public_values = proof[5] as usize;

    // The rest elements should be user set public values and should be `u32`.
    let public_values = proof[6..]
        .iter()
        .map(|v| Some(u32::try_from(*v).ok()?.to_le_bytes()))
        .take(num_user_public_values)
        .collect::<Option<Vec<_>>>()
        .ok_or(Error::InvalidPublicValue)?
        .into_iter()
        .flatten()
        .collect();

    Ok((rom_digest, public_values))
}

/// Returns path to `~/.zisk` directory.
fn dot_zisk_dir_path() -> PathBuf {
    PathBuf::from(env::var("HOME").expect("env `$HOME` should be set")).join(".zisk")
}
