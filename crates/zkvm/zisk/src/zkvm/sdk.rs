use crate::zkvm::Error;
use ere_zkvm_interface::zkvm::{CommonError, ProverResourceType, PublicValues};
use std::{
    collections::BTreeMap,
    env, fs,
    io::{BufRead, Write},
    iter,
    net::{Ipv4Addr, TcpStream},
    path::{Path, PathBuf},
    process::{Child, Command, Stdio},
    sync::OnceLock,
    thread,
    time::{Duration, Instant},
};
use strum::{EnumIter, IntoEnumIterator};
use tempfile::tempdir;
use tracing::{error, info};
use wait_timeout::ChildExt;

pub const START_SERVER_TIMEOUT: Duration = Duration::from_secs(120); // 2 mins
pub const SHUTDOWN_SERVER_TIMEOUT: Duration = Duration::from_secs(30); // 30 secs
pub const DEFAULT_PROVE_TIMEOUT: Duration = Duration::from_secs(3600); // 1 hour

/// Merkle root of ROM trace generated by `cargo-zisk rom-setup`.
pub type RomDigest = [u64; 4];

/// Options of `cargo-zisk` commands.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, EnumIter)]
pub enum ZiskOption {
    Port,
    UnlockMappedMemory, // Should be set if locked memory is not enough
    MinimalMemory,
    // GPU options
    Preallocate, // Should be set only if GPU memory is enough
    SharedTables,
    MaxStreams,
    NumberThreadsWitness,
    MaxWitnessStored,
}

impl ZiskOption {
    /// The key of the env variable to read from.
    fn env_var_key(&self) -> &'static str {
        match self {
            Self::Port => "ZISK_PORT",
            Self::UnlockMappedMemory => "ZISK_UNLOCK_MAPPED_MEMORY",
            Self::MinimalMemory => "ZISK_MINIMAL_MEMORY",
            Self::Preallocate => "ZISK_PREALLOCATE",
            Self::SharedTables => "ZISK_SHARED_TABLES",
            Self::MaxStreams => "ZISK_MAX_STREAMS",
            Self::NumberThreadsWitness => "ZISK_NUMBER_THREADS_WITNESS",
            Self::MaxWitnessStored => "ZISK_MAX_WITNESS_STORED",
        }
    }

    /// Whether the option is a flag (false-by-default boolean option) or not.
    ///
    /// When we read the option from env variable, if the option is a flag,
    /// we only check if the env variable is set or not.
    fn is_flag(&self) -> bool {
        match self {
            Self::UnlockMappedMemory
            | Self::MinimalMemory
            | Self::Preallocate
            | Self::SharedTables => true,
            Self::Port | Self::MaxStreams | Self::NumberThreadsWitness | Self::MaxWitnessStored => {
                false
            }
        }
    }

    /// The option key to be appended to `cargo-zisk` command arguments.
    fn key(&self) -> &'static str {
        match self {
            Self::Port => "--port",
            Self::UnlockMappedMemory => "--unlock-mapped-memory",
            // NOTE: Use snake case for `prove-client` command
            // Issue for tracking: https://github.com/eth-act/ere/issues/151.
            Self::MinimalMemory => "--minimal_memory",
            Self::Preallocate => "--preallocate",
            Self::SharedTables => "--shared-tables",
            Self::MaxStreams => "--max-streams",
            Self::NumberThreadsWitness => "--number-threads-witness",
            Self::MaxWitnessStored => "--max-witness-stored",
        }
    }
}

#[derive(Clone)]
pub struct ZiskOptions(BTreeMap<ZiskOption, String>);

impl ZiskOptions {
    /// Read options from env variables.
    pub fn from_env() -> Self {
        Self(
            ZiskOption::iter()
                .flat_map(|option| env::var(option.env_var_key()).ok().map(|val| (option, val)))
                .collect(),
        )
    }

    /// Returns `cargo-zisk` command arguments by given options that have been
    /// set.
    fn args(&self, options: impl IntoIterator<Item = ZiskOption>) -> impl Iterator<Item = &str> {
        options
            .into_iter()
            .filter(|option| self.0.contains_key(option))
            .flat_map(|option| {
                iter::once(option.key())
                    .chain((!option.is_flag()).then(|| self.0[&option].as_str()))
            })
    }

    /// Returns `cargo-zisk server` command arguments.
    fn server_args(&self) -> impl Iterator<Item = &str> {
        self.args([
            ZiskOption::Port,
            ZiskOption::UnlockMappedMemory,
            ZiskOption::Preallocate,
            ZiskOption::SharedTables,
            ZiskOption::MaxStreams,
            ZiskOption::NumberThreadsWitness,
            ZiskOption::MaxWitnessStored,
        ])
    }

    /// Returns `cargo-zisk prove-client` command arguments.
    fn prove_client_args(&self) -> impl Iterator<Item = &str> {
        self.args([ZiskOption::Port])
    }

    /// Returns `cargo-zisk prove-client prove` command arguments.
    fn prove_args(&self) -> impl Iterator<Item = &str> {
        self.prove_client_args()
            .chain(self.args([ZiskOption::MinimalMemory]))
    }
}

pub struct ZiskSdk {
    elf_path: PathBuf,
    cuda: bool,
    options: ZiskOptions,
    /// ROM digest will be setup only when `ZiskSdk::server` is called.
    ///
    /// Use `Option` inside because ROM setup might fail, we can get rid of
    /// it if `OnceLock::get_or_try_init` is stabilized.
    rom_digest: OnceLock<Option<RomDigest>>,
}

impl ZiskSdk {
    /// Returns SDK for the ELF.
    pub fn new(
        elf: Vec<u8>,
        resource: ProverResourceType,
        options: ZiskOptions,
    ) -> Result<Self, Error> {
        if matches!(resource, ProverResourceType::Network(_)) {
            panic!("Network proving not yet implemented for ZisK. Use CPU or GPU resource type.");
        }
        // Save ELF to `~/.zisk/cache` along with the ROM binaries, to avoid it
        // been cleaned up during a long run process.
        let cache_dir_path = dot_zisk_dir_path().join("cache");
        fs::create_dir_all(&cache_dir_path)
            .map_err(|err| CommonError::create_dir("cache", &cache_dir_path, err))?;

        // Use blake3 hash as the ELF file name, since ROM setup uses blake3 as
        // unique identifier as well.
        let elf_hash = blake3::hash(&elf);
        let elf_path = cache_dir_path.join(format!("{elf_hash}.elf"));

        fs::write(&elf_path, elf).map_err(|err| CommonError::write_file("elf", &elf_path, err))?;

        Ok(Self {
            elf_path,
            cuda: matches!(resource, ProverResourceType::Gpu),
            options,
            rom_digest: OnceLock::new(),
        })
    }

    /// Execute the ELF with the given `input`.
    pub fn execute(&self, input: &[u8]) -> Result<(PublicValues, u64), Error> {
        let tempdir = tempdir().map_err(CommonError::tempdir)?;
        let input_path = tempdir.path().join("input");
        let output_path = tempdir.path().join("output");

        fs::write(&input_path, input)
            .map_err(|err| CommonError::write_file("input", &input_path, err))?;

        let mut cmd = Command::new("ziskemu");
        let output = cmd
            .arg("--elf")
            .arg(&self.elf_path)
            .arg("--inputs")
            .arg(input_path)
            .arg("--output")
            .arg(&output_path)
            .arg("--stats") // Enable stats in order to get total steps.
            .output()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if !output.status.success() {
            return Err(CommonError::command_exit_non_zero(
                &cmd,
                output.status,
                Some(&output),
            ))?;
        }

        // Extract cycle count from the stdout.

        let total_num_cycles = String::from_utf8_lossy(&output.stdout)
            .split_once("STEPS")
            .and_then(|(_, stats)| {
                stats
                    .split_whitespace()
                    .next()
                    .and_then(|steps| steps.replace(",", "").parse::<u64>().ok())
            })
            .ok_or(Error::TotalStepsNotFound)?;

        let public_values = fs::read(&output_path)
            .map_err(|err| CommonError::read_file("output", &output_path, err))?;

        Ok((public_values, total_num_cycles))
    }

    /// Returns the ROM digest of the ELF.
    ///
    /// If it is not setup yet, it makes sure the global setup is done, then
    /// does ROM setup of the ELF and stores the ROM digest for later usage.
    pub fn rom_digest(&self) -> Result<RomDigest, Error> {
        // FIXME: Use `get_or_try_init` when it is stabilized
        let mut result = Ok(());
        let rom_digest = *self.rom_digest.get_or_init(|| {
            check_setup(self.cuda)
                .and_then(|_| rom_setup(&self.elf_path))
                .map_err(|err| result = Err(err))
                .ok()
        });
        result?;
        rom_digest.ok_or(Error::RomSetupFailedBefore)
    }

    /// Start a server of the ELF.
    pub fn server(&self) -> Result<ZiskServer, Error> {
        // Setup ROM and get ROM digest if it's not done yet.
        let rom_digest = self.rom_digest()?;

        let (cargo_zisk, witness_lib_path) = if self.cuda {
            let witness_lib_path = dot_zisk_dir_path()
                .join("bin")
                .join("libzisk_witness_cuda.so");
            ("cargo-zisk-cuda", Some(witness_lib_path))
        } else {
            ("cargo-zisk", None)
        };

        info!("Starting ZisK server...");

        let mut cmd = Command::new(cargo_zisk);
        cmd.arg("server")
            .args(self.options.server_args())
            .arg("--elf")
            .arg(&self.elf_path)
            .arg("--aggregation");
        if let Some(witness_lib_path) = witness_lib_path {
            cmd.arg("--witness-lib").arg(witness_lib_path);
        }

        let child = cmd.spawn().map_err(|err| CommonError::command(&cmd, err))?;
        let server = ZiskServer {
            options: self.options.clone(),
            rom_digest,
            child,
        };

        server.wait_until_ready()?;

        Ok(server)
    }

    /// Verify the proof of the ELF, and returns public values.
    pub fn verify(&self, proof: &[u8]) -> Result<PublicValues, Error> {
        let rom_digest = self.rom_digest()?;

        let tempdir = tempdir().map_err(CommonError::tempdir)?;
        let proof_path = tempdir.path().join("proof");

        fs::write(&proof_path, proof)
            .map_err(|err| CommonError::write_file("proof", &proof_path, err))?;

        let mut cmd = Command::new("cargo-zisk");
        let output = cmd
            .arg("verify")
            .arg("--proof")
            .arg(&proof_path)
            .output()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if !output.status.success() {
            Err(Error::InvalidProof(
                String::from_utf8_lossy(&output.stderr).to_string(),
            ))?
        }

        let proof = fs::read(&proof_path)
            .map_err(|err| CommonError::read_file("proof", &proof_path, err))?;

        // Deserialize public values.
        let (proved_rom_digest, public_values) = deserialize_public_values(&proof)?;

        // The proved ROM digest should be equal to preprocessed one.
        if proved_rom_digest != rom_digest {
            return Err(Error::UnexpectedRomDigest {
                preprocessed: rom_digest,
                proved: proved_rom_digest,
            });
        }

        Ok(public_values)
    }
}

/// ZisK server status returned from `cargo-zisk prove-client status`.
#[derive(Debug)]
pub enum ZiskServerStatus {
    Idle,
    Working,
}

/// Wrapper for ZisK server child process.
pub struct ZiskServer {
    options: ZiskOptions,
    rom_digest: RomDigest,
    child: Child,
}

impl Drop for ZiskServer {
    fn drop(&mut self) {
        info!("Shutting down ZisK server");

        let mut cmd = Command::new("cargo-zisk");
        let result = cmd
            .args(["prove-client", "shutdown"])
            .args(self.options.prove_client_args())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .and_then(
                |mut child| match child.wait_timeout(SHUTDOWN_SERVER_TIMEOUT)? {
                    Some(_) => child.wait_with_output(),
                    None => {
                        child.kill().ok();
                        Err(std::io::Error::other("shutdown command timed out"))
                    }
                },
            );

        if result.as_ref().is_ok_and(|output| output.status.success()) {
            info!("Shutdown ZisK server");
        } else {
            error!(
                "Failed to shutdown ZisK server: {}",
                result
                    .map(|output| String::from_utf8_lossy(&output.stderr).to_string())
                    .unwrap_or_else(|err| err.to_string())
            );
            error!("Shutdown server child process and asm services manually...");
            let _ = self.child.kill();
            shutdown_asm_service(23115);
            shutdown_asm_service(23116);
            shutdown_asm_service(23117);
            remove_shm_files();
        }
    }
}

impl ZiskServer {
    /// Get status of server.
    pub fn status(&self, timeout: Duration) -> Result<ZiskServerStatus, Error> {
        let mut cmd = Command::new("cargo-zisk");
        let mut child = cmd
            .args(["prove-client", "status"])
            .args(self.options.prove_client_args())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if child
            .wait_timeout(timeout)
            .map_err(|err| CommonError::command(&cmd, err))?
            .is_none()
        {
            // Timeout reached, kill the process
            child.kill().ok();
            return Err(Error::TimeoutWaitingServerReady);
        }

        let output = child
            .wait_with_output()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if !output.status.success() {
            return Err(CommonError::command_exit_non_zero(
                &cmd,
                output.status,
                Some(&output),
            ))?;
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        if stdout.contains("idle") {
            Ok(ZiskServerStatus::Idle)
        } else if stdout.contains("working") {
            Ok(ZiskServerStatus::Working)
        } else {
            Err(Error::UnknownServerStatus {
                stdout: stdout.to_string(),
            })
        }
    }

    /// Send prove request to server and wait for proof to be created.
    pub fn prove(&mut self, input: &[u8]) -> Result<(PublicValues, Vec<u8>), Error> {
        // Prefix that ZisK server will add to the file name of the proof.
        // We use constant because the file will be save to a temporary dir,
        // so there will be no conflict.
        const PREFIX: &str = "ere";

        let tempdir = tempdir().map_err(CommonError::tempdir)?;
        let input_path = tempdir.path().join("input");
        let output_path = tempdir.path().join("output");
        let proof_path = output_path.join(format!("{PREFIX}-vadcop_final_proof.bin"));

        fs::write(&input_path, input)
            .map_err(|err| CommonError::write_file("input", &input_path, err))?;

        // NOTE: Use snake case for `prove-client` command
        // Issue for tracking: https://github.com/eth-act/ere/issues/151.
        let mut cmd = Command::new("cargo-zisk");
        let output = cmd
            .args(["prove-client", "prove"])
            .arg("--input")
            .arg(input_path)
            .arg("--output_dir")
            .arg(&output_path)
            .args(["-p", PREFIX])
            .args(["--aggregation", "--verify_proofs"])
            .args(self.options.prove_args())
            .output()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if !output.status.success() {
            return Err(CommonError::command_exit_non_zero(
                &cmd,
                output.status,
                Some(&output),
            ))?;
        }

        // By default set 1 hour timeout for prove.
        let prove_timeout = env::var("ZISK_PROVE_TIMEOUT_SEC")
            .ok()
            .and_then(|timeout| timeout.parse::<u64>().ok())
            .map(Duration::from_secs)
            .unwrap_or(DEFAULT_PROVE_TIMEOUT);

        // ZisK server will finish the `prove` requested above then respond the
        // following `status`. So if the following `status` succeeds, the proof
        // should also be ready.
        self.status(prove_timeout).map_err(|err| {
            if matches!(err, Error::TimeoutWaitingServerReady) {
                Error::TimeoutWaitingServerProving
            } else if err.to_string().contains("EOF") {
                Error::ServerCrashed
            } else {
                err
            }
        })?;

        let proof = fs::read(&proof_path)
            .map_err(|err| CommonError::read_file("proof", &proof_path, err))?;

        // Deserialize public values.
        let (proved_rom_digest, public_values) = deserialize_public_values(&proof)?;

        // The proved ROM digest should be equal to preprocessed one.
        if proved_rom_digest != self.rom_digest {
            return Err(Error::UnexpectedRomDigest {
                preprocessed: self.rom_digest,
                proved: proved_rom_digest,
            });
        }

        Ok((public_values, proof))
    }

    /// Wait until the server status to be idle.
    fn wait_until_ready(&self) -> Result<(), Error> {
        const INTERVAL: Duration = Duration::from_secs(1);

        info!("Waiting until server is ready...");

        let start = Instant::now();
        while !matches!(
            self.status(START_SERVER_TIMEOUT),
            Ok(ZiskServerStatus::Idle)
        ) {
            if start.elapsed() > START_SERVER_TIMEOUT {
                return Err(Error::TimeoutWaitingServerReady);
            }
            thread::sleep(INTERVAL);
        }

        Ok(())
    }
}

/// Does global setup if it is not done yet.
fn check_setup(cuda: bool) -> Result<(), Error> {
    info!("Running command `cargo-zisk check-setup --aggregation`...");

    let cargo_zisk = if cuda {
        "cargo-zisk-cuda"
    } else {
        "cargo-zisk"
    };

    let mut cmd = Command::new(cargo_zisk);
    let output = cmd
        .args(["check-setup", "--aggregation"])
        .output()
        .map_err(|err| CommonError::command(&cmd, err))?;

    if !output.status.success() {
        Err(CommonError::command_exit_non_zero(
            &cmd,
            output.status,
            Some(&output),
        ))?;
    }

    info!("Command `cargo-zisk check-setup --aggregation` succeeded");

    Ok(())
}

/// Does ROM setup of the ELF and returns the ROM digest.
fn rom_setup(elf_path: &Path) -> Result<RomDigest, Error> {
    info!("Running command `cargo-zisk rom-setup` ...");

    let mut cmd = Command::new("cargo-zisk");
    let output = cmd
        .arg("rom-setup")
        .arg("--elf")
        .arg(elf_path)
        .output()
        .map_err(|err| CommonError::command(&cmd, err))?;

    if !output.status.success() {
        Err(CommonError::command_exit_non_zero(
            &cmd,
            output.status,
            Some(&output),
        ))?;
    }

    // Parse the ROM digest from the stdout.
    let rom_digest = output
        .stdout
        .lines()
        .find_map(|line| {
            let line = line.ok()?;
            let line = line.split_once("Root hash: [")?.1;
            let line = line.strip_suffix("]")?;
            line.split(", ")
                .filter_map(|word| word.parse::<u64>().ok())
                .collect::<Vec<_>>()
                .try_into()
                .ok()
        })
        .ok_or(Error::RomDigestNotFound)?;

    info!("Command `cargo-zisk rom-setup` succeeded");

    Ok(rom_digest)
}

/// Send shutdown request to ZisK asm services.
fn shutdown_asm_service(port: u16) {
    // According to https://github.com/0xPolygonHermez/zisk/blob/v0.14.0/emulator-asm/asm-runner/src/asm_services/mod.rs#L34.
    const CMD_SHUTDOWN_REQUEST_ID: u64 = 1000000;
    if let Ok(mut stream) = TcpStream::connect((Ipv4Addr::LOCALHOST, port)) {
        let _ = stream.write_all(
            &[CMD_SHUTDOWN_REQUEST_ID, 0, 0, 0, 0]
                .into_iter()
                .flat_map(|word| word.to_le_bytes())
                .collect::<Vec<_>>(),
        );
    }
}

/// Remove shared memory created by ZisK.
fn remove_shm_files() {
    let Ok(shm_dir) = fs::read_dir(Path::new("/dev/shm")) else {
        return;
    };

    for entry in shm_dir.flatten() {
        let path = entry.path();
        if path
            .file_name()
            .and_then(|n| n.to_str())
            .is_some_and(|name| name.starts_with("ZISK") || name.starts_with("sem"))
        {
            let _ = fs::remove_file(&path);
        }
    }
}

/// Deserialize public values as json string sequence, and parse the `RomDigest`
/// and user set public values as `Vec<u8>`.
fn deserialize_public_values(proof: &[u8]) -> Result<(RomDigest, Vec<u8>), Error> {
    let proof = bytemuck::try_cast_slice::<_, u64>(proof).map_err(Error::CastProofBytesToU64s)?;

    // The public values contain at least the the total number of public values,
    // `RomDigest`, and the number of user set public values.
    if proof.len() < 6 {
        return Err(Error::InvalidPublicValuesLength(proof.len()));
    }

    // The first element is total number of public values.

    // The next 4 elements of public values should be ROM digest.
    let rom_digest = proof[1..5].try_into().unwrap();

    // The next element should be the number of user set public values.
    let num_user_public_values = proof[5] as usize;

    // The rest elements should be user set public values and should be `u32`.
    let public_values = proof[6..]
        .iter()
        .map(|v| Some(u32::try_from(*v).ok()?.to_le_bytes()))
        .take(num_user_public_values)
        .collect::<Option<Vec<_>>>()
        .ok_or(Error::InvalidPublicValue)?
        .into_iter()
        .flatten()
        .collect();

    Ok((rom_digest, public_values))
}

/// Returns path to `~/.zisk` directory.
fn dot_zisk_dir_path() -> PathBuf {
    PathBuf::from(env::var("HOME").expect("env `$HOME` should be set")).join(".zisk")
}
