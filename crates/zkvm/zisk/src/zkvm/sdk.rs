use crate::zkvm::Error;
use crate::zkvm::cluster_client::ClusterClient;
use crate::zkvm::server::{ZiskServer, ZiskServerOptions};
use ere_zkvm_interface::zkvm::{CommonError, ProverResource, ProverResourceKind, PublicValues};
use std::borrow::Cow;
use std::path::Path;
use std::process::Command;
use std::{
    env, fs,
    io::BufRead,
    mem::transmute,
    path::PathBuf,
    sync::OnceLock,
    time::{Duration, Instant},
};
use tempfile::tempdir;
use tracing::info;

/// Verifying key of the aggregation proof.
///
/// Extracted from `$HOME/.zisk/provingKey/zisk/vadcop_final/vadcop_final.verkey.json`.
pub const VADCOP_FINAL_VK: [u8; 32] = unsafe {
    // Use `transmute` to keep the endianness because `zisk_proofman_verifier::verify` will
    // use `bytemuck` to cast it to `[u64; 4]`.
    transmute([
        723851053263266420u64,
        2272245643171245153u64,
        9868173762158752255u64,
        6004219199197288727u64,
    ])
};

/// Merkle root of ROM trace generated by `cargo-zisk rom-setup`.
pub type RomDigest = [u64; 4];

pub enum ZiskProver {
    Server(ZiskServer),
    Cluster(ClusterClient),
}

pub struct ZiskSdk {
    elf_path: PathBuf,
    resource: ProverResource,
    /// ROM digest will be setup only when `ZiskSdk::prove` or `ZiskSdk::verify`
    /// is called.
    ///
    /// Use `Option` inside because ROM setup might fail, we can get rid of
    /// it if `OnceLock::get_or_try_init` is stabilized.
    rom_digest: OnceLock<Option<RomDigest>>,
    /// Prover instance, either a local server or a cluster client.
    prover: ZiskProver,
}

impl ZiskSdk {
    /// Returns SDK for the ELF.
    pub fn new(elf: Vec<u8>, resource: ProverResource) -> Result<Self, Error> {
        // Save ELF to `~/.zisk/cache` along with the ROM binaries, to avoid it
        // been cleaned up during a long run process.
        let cache_dir_path = dot_zisk_dir_path().join("cache");
        fs::create_dir_all(&cache_dir_path)
            .map_err(|err| CommonError::create_dir("cache", &cache_dir_path, err))?;

        // Use blake3 hash as the ELF file name, since ROM setup uses blake3 as
        // unique identifier as well.
        let elf_hash = blake3::hash(&elf);
        let elf_path = cache_dir_path.join(format!("{elf_hash}.elf"));

        fs::write(&elf_path, elf).map_err(|err| CommonError::write_file("elf", &elf_path, err))?;

        let prover = match &resource {
            ProverResource::Cpu | ProverResource::Gpu => ZiskProver::Server(ZiskServer::new(
                &elf_path,
                resource.is_gpu(),
                ZiskServerOptions::from_env(),
            )),
            ProverResource::Cluster(config) => ZiskProver::Cluster(ClusterClient::new(config)?),
            _ => Err(CommonError::unsupported_prover_resource_kind(
                resource.kind(),
                [
                    ProverResourceKind::Cpu,
                    ProverResourceKind::Gpu,
                    ProverResourceKind::Cluster,
                ],
            ))?,
        };

        let sdk = Self {
            elf_path,
            resource,
            rom_digest: OnceLock::new(),
            prover,
        };

        if env::var_os("ZISK_SETUP_ON_INIT").is_some() {
            sdk.rom_digest()?;
        }

        Ok(sdk)
    }

    /// Execute the ELF with the given `input`.
    pub fn execute(&self, input: &[u8]) -> Result<(PublicValues, u64), Error> {
        let tempdir = tempdir().map_err(CommonError::tempdir)?;
        let input_path = tempdir.path().join("input");
        let output_path = tempdir.path().join("output");

        fs::write(&input_path, input)
            .map_err(|err| CommonError::write_file("input", &input_path, err))?;

        let mut cmd = Command::new("ziskemu");
        let output = cmd
            .arg("--elf")
            .arg(&self.elf_path)
            .arg("--inputs")
            .arg(input_path)
            .arg("--output")
            .arg(&output_path)
            .arg("--stats") // Enable stats in order to get total steps.
            .output()
            .map_err(|err| CommonError::command(&cmd, err))?;

        if !output.status.success() {
            return Err(CommonError::command_exit_non_zero(
                &cmd,
                output.status,
                Some(&output),
            ))?;
        }

        // Extract cycle count from the stdout.

        let total_num_cycles = String::from_utf8_lossy(&output.stdout)
            .split_once("STEPS")
            .and_then(|(_, stats)| {
                stats
                    .split_whitespace()
                    .next()
                    .and_then(|steps| steps.replace(",", "").parse::<u64>().ok())
            })
            .ok_or(Error::TotalStepsNotFound)?;

        let public_values = fs::read(&output_path)
            .map_err(|err| CommonError::read_file("output", &output_path, err))?;

        Ok((public_values, total_num_cycles))
    }

    /// Returns the ROM digest of the ELF.
    ///
    /// If it is not setup yet, it makes sure the global setup is done, then
    /// does ROM setup of the ELF and stores the ROM digest for later usage.
    pub fn rom_digest(&self) -> Result<RomDigest, Error> {
        // FIXME: Use `get_or_try_init` when it is stabilized
        let mut result = Ok(());
        let rom_digest = *self.rom_digest.get_or_init(|| {
            check_setup(self.resource.is_gpu())
                .and_then(|_| rom_setup(&self.elf_path))
                .map_err(|err| result = Err(err))
                .ok()
        });
        result?;
        rom_digest.ok_or(Error::RomSetupFailedBefore)
    }

    /// Prove the ELF with the given input.
    ///
    /// Returns the public values, proof, and proving time.
    pub fn prove(&self, input: &[u8]) -> Result<(PublicValues, Vec<u8>, Duration), Error> {
        let (proof, proving_time) = match &self.prover {
            ZiskProver::Cluster(client) => client.prove(input)?,
            ZiskProver::Server(server) => {
                self.rom_digest()?;

                let start = Instant::now();
                let proof = server.prove(input)?;
                let proving_time = start.elapsed();

                (proof, proving_time)
            }
        };

        // The proved ROM digest should be equal to preprocessed one.
        let (proved_rom_digest, public_values) = deserialize_public_values(&proof)?;
        let rom_digest = self.rom_digest()?;
        if proved_rom_digest != rom_digest {
            return Err(Error::UnexpectedRomDigest {
                preprocessed: rom_digest,
                proved: proved_rom_digest,
            });
        }

        Ok((public_values, proof, proving_time))
    }

    /// Verify the proof of the ELF, and returns public values.
    pub fn verify(&self, proof: &[u8]) -> Result<PublicValues, Error> {
        let proof = align_to_u64(proof)?;

        if !zisk_proofman_verifier::verify(&proof, &VADCOP_FINAL_VK) {
            Err(Error::InvalidProof)?
        }

        // Deserialize public values.
        let (proved_rom_digest, public_values) = deserialize_public_values(&proof)?;

        let rom_digest = self.rom_digest()?;

        // The proved ROM digest should be equal to preprocessed one.
        if proved_rom_digest != rom_digest {
            return Err(Error::UnexpectedRomDigest {
                preprocessed: rom_digest,
                proved: proved_rom_digest,
            });
        }

        Ok(public_values)
    }
}

/// Does global setup if it is not done yet.
fn check_setup(cuda: bool) -> Result<(), Error> {
    info!("Running command `cargo-zisk check-setup --aggregation`...");

    let cargo_zisk = if cuda {
        "cargo-zisk-cuda"
    } else {
        "cargo-zisk"
    };

    let mut cmd = Command::new(cargo_zisk);
    let output = cmd
        .args(["check-setup", "--aggregation"])
        .output()
        .map_err(|err| CommonError::command(&cmd, err))?;

    if !output.status.success() {
        Err(CommonError::command_exit_non_zero(
            &cmd,
            output.status,
            Some(&output),
        ))?;
    }

    info!("Command `cargo-zisk check-setup --aggregation` succeeded");

    Ok(())
}

/// Does ROM setup of the ELF and returns the ROM digest.
fn rom_setup(elf_path: &Path) -> Result<RomDigest, Error> {
    info!("Running command `cargo-zisk rom-setup` ...");

    let mut cmd = Command::new("cargo-zisk");
    let output = cmd
        .arg("rom-setup")
        .arg("--elf")
        .arg(elf_path)
        .output()
        .map_err(|err| CommonError::command(&cmd, err))?;

    if !output.status.success() {
        Err(CommonError::command_exit_non_zero(
            &cmd,
            output.status,
            Some(&output),
        ))?;
    }

    // Parse the ROM digest from the stdout.
    let rom_digest = output
        .stdout
        .lines()
        .find_map(|line| {
            let line = line.ok()?;
            let line = line.split_once("Root hash: [")?.1;
            let line = line.strip_suffix("]")?;
            line.split(", ")
                .filter_map(|word| word.parse::<u64>().ok())
                .collect::<Vec<_>>()
                .try_into()
                .ok()
        })
        .ok_or(Error::RomDigestNotFound)?;

    info!("Command `cargo-zisk rom-setup` succeeded");

    Ok(rom_digest)
}

/// Deserialize public values as json string sequence, and parse the `RomDigest`
/// and user set public values as `Vec<u8>`.
fn deserialize_public_values(proof: &[u8]) -> Result<(RomDigest, Vec<u8>), Error> {
    let proof = align_to_u64(proof)?;
    let proof = bytemuck::cast_slice::<u8, u64>(&proof);

    // The public values contain at least the the total number of public values,
    // `RomDigest`, and the number of user set public values.
    if proof.len() < 6 {
        return Err(Error::InvalidPublicValuesLength(proof.len()));
    }

    // The first element is total number of public values.

    // The next 4 elements of public values should be ROM digest.
    let rom_digest = proof[1..5].try_into().unwrap();

    // The next element should be the number of user set public values.
    let num_user_public_values = proof[5] as usize;

    // The rest elements should be user set public values and should be `u32`.
    let public_values = proof[6..]
        .iter()
        .map(|v| Some(u32::try_from(*v).ok()?.to_le_bytes()))
        .take(num_user_public_values)
        .collect::<Option<Vec<_>>>()
        .ok_or(Error::InvalidPublicValue)?
        .into_iter()
        .flatten()
        .collect();

    Ok((rom_digest, public_values))
}

/// Returns u64-aligned bytes.
///
/// Returns an error if `data.len()` is not a multiple of 8.
fn align_to_u64(data: &[u8]) -> Result<Cow<'_, [u8]>, Error> {
    if !data.len().is_multiple_of(8) {
        return Err(Error::InvalidProofSize(data.len()));
    }
    Ok(if data.as_ptr().cast::<u64>().is_aligned() {
        Cow::Borrowed(data)
    } else {
        let mut aligned: Vec<u64> = vec![0; data.len() / 8];
        bytemuck::cast_slice_mut(&mut aligned).copy_from_slice(data);
        Cow::Owned(bytemuck::cast_slice(&aligned).to_vec())
    })
}

/// Returns path to `~/.zisk` directory.
pub(crate) fn dot_zisk_dir_path() -> PathBuf {
    PathBuf::from(env::var("HOME").expect("env `$HOME` should be set")).join(".zisk")
}
